{"ast":null,"code":"var validator = require('validator');\n\nvalidator.toUpper = function (str) {\n  return str.toUpperCase();\n};\n\nvalidator.toLower = function (str) {\n  return str.toLowerCase();\n};\n\nvar morxParamExtractor = {};\n\nfunction validateParamValue(value, validators) {\n  var no_errors = true;\n  var message = [];\n  validators.forEach(function (v) {\n    vFunc = validator[v];\n\n    if (vFunc) {\n      if (!vFunc(value + '')) {\n        message.push(value + \" failed \" + v + \" validation\");\n        no_errors = false;\n        return;\n      }\n    } else {\n      throwErrorWhen(true, 'Validator ' + v + ' not found');\n    }\n  });\n  return {\n    no_errors: no_errors,\n    message: message.join(', ')\n  };\n}\n\nfunction transformParamValue(value, filters) {\n  filters.forEach(function (f) {\n    filter = validator[f];\n\n    if (filter) {\n      value = filter(value + '');\n    } else {\n      throwErrorWhen(true, 'Filter ' + f + ' not found');\n    }\n  });\n  return value;\n}\n\nfunction throwErrorWhen(error_flag, message) {\n  if (!message) return;\n\n  if (error_flag) {\n    throw new Error(message);\n  }\n}\n\nmorxParamExtractor.registerValidator = function (validator_name, validator_func) {//todo v2\n};\n\nmorxParamExtractor.registerFilter = function (filter_name, filter_func) {//todo v2\n}; //Todo v2 .. add multiple support for multiple param sources\n\n\nmorxParamExtractor.paramExtract = function (param_source, param_spec, options) {\n  param_source = param_source || {};\n  param_spec = param_spec || {};\n  options = options || {};\n  var extracted_params = {};\n  var error_messages = [];\n  var failed_params = [];\n  var not_param_values = {};\n  var no_errors = true;\n\n  for (var param in param_spec) {\n    if (param_spec.hasOwnProperty(param)) {\n      var spec = param_spec[param];\n      var filters = spec.filters ? spec.filters.split('.') : [];\n      var validators = spec.validators ? spec.validators.split('.') : [];\n      var param_value = param_source[param];\n\n      if (spec.required == 'true' && (typeof param_value == 'undefined' || param_value === \"\")) {\n        no_errors = false;\n        error_messages.push(param + ' is required');\n        failed_params.push(param);\n        throwErrorWhen(options.throw_error_on_first_fail, error_messages.join(','));\n\n        if (options.fail_on_first_error) {\n          break;\n        }\n      } else {\n        if (typeof param_value != 'undefined') {\n          var validated = validateParamValue(param_value, validators);\n\n          if (validated.no_errors) {\n            param_value = transformParamValue(param_value, filters); //If value is not needed as an extracted param ignore it.\n\n            if (!spec.not_param) {\n              if (!spec.map) {\n                if (param_value) extracted_params[param] = param_value;\n              } else {\n                if (param_value) extracted_params[spec.map] = param_value;\n              }\n            } else {\n              if (param_value) not_param_values[param] = param_value;\n            }\n          } else {\n            no_errors = false;\n            error_messages.push(validated.message);\n            failed_params.push(param);\n            throwErrorWhen(options.throw_error_on_first_fail, validated.message);\n\n            if (options.fail_on_first_error) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  throwErrorWhen(options.throw_error, error_messages.join(' , '));\n  return {\n    no_errors: no_errors,\n    params: extracted_params,\n    failed_params: failed_params,\n    excluded_params: not_param_values,\n    error_messages: error_messages.join(' , ')\n  };\n};\n\nmodule.exports = morxParamExtractor;","map":{"version":3,"sources":["C:/Users/Obed/PycharmProjects/akmarv_project/node_modules/morx/lib/morx.param.extractor.js"],"names":["validator","require","toUpper","str","toUpperCase","toLower","toLowerCase","morxParamExtractor","validateParamValue","value","validators","no_errors","message","forEach","v","vFunc","push","throwErrorWhen","join","transformParamValue","filters","f","filter","error_flag","Error","registerValidator","validator_name","validator_func","registerFilter","filter_name","filter_func","paramExtract","param_source","param_spec","options","extracted_params","error_messages","failed_params","not_param_values","param","hasOwnProperty","spec","split","param_value","required","throw_error_on_first_fail","fail_on_first_error","validated","not_param","map","throw_error","params","excluded_params","module","exports"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAvB;;AAEAD,SAAS,CAACE,OAAV,GAAoB,UAAUC,GAAV,EAAe;AAClC,SAAOA,GAAG,CAACC,WAAJ,EAAP;AACA,CAFD;;AAIAJ,SAAS,CAACK,OAAV,GAAoB,UAAUF,GAAV,EAAe;AAClC,SAAOA,GAAG,CAACG,WAAJ,EAAP;AACA,CAFD;;AAGA,IAAIC,kBAAkB,GAAG,EAAzB;;AAEA,SAASC,kBAAT,CAA4BC,KAA5B,EAAmCC,UAAnC,EAA+C;AAE9C,MAAIC,SAAS,GAAG,IAAhB;AACA,MAAIC,OAAO,GAAK,EAAhB;AACAF,EAAAA,UAAU,CAACG,OAAX,CAAoB,UAAUC,CAAV,EAAa;AAChCC,IAAAA,KAAK,GAAGf,SAAS,CAACc,CAAD,CAAjB;;AAEA,QAAGC,KAAH,EAAS;AAER,UAAG,CAACA,KAAK,CAACN,KAAK,GAAG,EAAT,CAAT,EAAsB;AACrBG,QAAAA,OAAO,CAACI,IAAR,CAAaP,KAAK,GAAG,UAAR,GAAqBK,CAArB,GAAyB,aAAtC;AACAH,QAAAA,SAAS,GAAG,KAAZ;AACA;AACA;AACD,KAPD,MASA;AACCM,MAAAA,cAAc,CAAC,IAAD,EAAO,eAAeH,CAAf,GAAmB,YAA1B,CAAd;AACA;AAED,GAhBD;AAkBA,SAAO;AACLH,IAAAA,SAAS,EAAEA,SADN;AAELC,IAAAA,OAAO,EAAEA,OAAO,CAACM,IAAR,CAAa,IAAb;AAFJ,GAAP;AAIA;;AAED,SAASC,mBAAT,CAA6BV,KAA7B,EAAoCW,OAApC,EAA6C;AAE5CA,EAAAA,OAAO,CAACP,OAAR,CAAiB,UAAUQ,CAAV,EAAa;AAE7BC,IAAAA,MAAM,GAAGtB,SAAS,CAACqB,CAAD,CAAlB;;AACA,QAAIC,MAAJ,EACA;AACCb,MAAAA,KAAK,GAAGa,MAAM,CAACb,KAAK,GAAG,EAAT,CAAd;AACA,KAHD,MAKA;AACCQ,MAAAA,cAAc,CAAC,IAAD,EAAO,YAAYI,CAAZ,GAAgB,YAAvB,CAAd;AACA;AACD,GAXD;AAaA,SAAOZ,KAAP;AACA;;AAED,SAASQ,cAAT,CAAwBM,UAAxB,EAAoCX,OAApC,EAA6C;AAC5C,MAAG,CAACA,OAAJ,EAAa;;AACb,MAAGW,UAAH,EAAc;AACb,UAAM,IAAIC,KAAJ,CAAUZ,OAAV,CAAN;AACA;AACD;;AAEDL,kBAAkB,CAACkB,iBAAnB,GAAuC,UAAUC,cAAV,EAA0BC,cAA1B,EAA0C,CAChF;AACA,CAFD;;AAKApB,kBAAkB,CAACqB,cAAnB,GAAoC,UAAUC,WAAV,EAAuBC,WAAvB,EAAoC,CACvE;AACA,CAFD,C,CAIA;;;AACAvB,kBAAkB,CAACwB,YAAnB,GAAkC,UAAUC,YAAV,EAAwBC,UAAxB,EAAoCC,OAApC,EAA4C;AAC7EF,EAAAA,YAAY,GAAGA,YAAY,IAAI,EAA/B;AACAC,EAAAA,UAAU,GAAKA,UAAU,IAAM,EAA/B;AACAC,EAAAA,OAAO,GAAQA,OAAO,IAAS,EAA/B;AAEA,MAAIC,gBAAgB,GAAG,EAAvB;AACA,MAAIC,cAAc,GAAK,EAAvB;AACA,MAAIC,aAAa,GAAM,EAAvB;AACA,MAAIC,gBAAgB,GAAG,EAAvB;AAEA,MAAI3B,SAAS,GAAG,IAAhB;;AAEA,OAAI,IAAI4B,KAAR,IAAiBN,UAAjB,EAA4B;AAE3B,QAAIA,UAAU,CAACO,cAAX,CAA0BD,KAA1B,CAAJ,EAAsC;AAErC,UAAIE,IAAI,GAAGR,UAAU,CAACM,KAAD,CAArB;AAEA,UAAInB,OAAO,GAAMqB,IAAI,CAACrB,OAAL,GAAkBqB,IAAI,CAACrB,OAAL,CAAasB,KAAb,CAAmB,GAAnB,CAAlB,GAA+C,EAAhE;AACA,UAAIhC,UAAU,GAAG+B,IAAI,CAAC/B,UAAL,GAAkB+B,IAAI,CAAC/B,UAAL,CAAgBgC,KAAhB,CAAsB,GAAtB,CAAlB,GAA+C,EAAhE;AAEA,UAAIC,WAAW,GAAGX,YAAY,CAACO,KAAD,CAA9B;;AAEA,UAAGE,IAAI,CAACG,QAAL,IAAiB,MAAjB,KAA4B,OAAOD,WAAP,IAAsB,WAAtB,IAAqCA,WAAW,KAAK,EAAjF,CAAH,EAAwF;AACvFhC,QAAAA,SAAS,GAAG,KAAZ;AACAyB,QAAAA,cAAc,CAACpB,IAAf,CAAqBuB,KAAK,GAAG,cAA7B;AACAF,QAAAA,aAAa,CAACrB,IAAd,CAAmBuB,KAAnB;AACAtB,QAAAA,cAAc,CAACiB,OAAO,CAACW,yBAAT,EAAoCT,cAAc,CAAClB,IAAf,CAAoB,GAApB,CAApC,CAAd;;AACA,YAAGgB,OAAO,CAACY,mBAAX,EAA+B;AAC9B;AACA;AACD,OARD,MAUA;AACC,YAAG,OAAOH,WAAP,IAAsB,WAAzB,EAAqC;AAEpC,cAAII,SAAS,GAAGvC,kBAAkB,CAACmC,WAAD,EAAcjC,UAAd,CAAlC;;AACA,cAAGqC,SAAS,CAACpC,SAAb,EACA;AAECgC,YAAAA,WAAW,GAAGxB,mBAAmB,CAACwB,WAAD,EAAcvB,OAAd,CAAjC,CAFD,CAGC;;AACA,gBAAG,CAACqB,IAAI,CAACO,SAAT,EAAmB;AAClB,kBAAG,CAACP,IAAI,CAACQ,GAAT,EACA;AACC,oBAAGN,WAAH,EACAR,gBAAgB,CAACI,KAAD,CAAhB,GAA0BI,WAA1B;AACA,eAJD,MAMA;AACC,oBAAGA,WAAH,EACAR,gBAAgB,CAACM,IAAI,CAACQ,GAAN,CAAhB,GAA6BN,WAA7B;AACA;AACD,aAXD,MAaA;AACC,kBAAGA,WAAH,EACAL,gBAAgB,CAACC,KAAD,CAAhB,GAA0BI,WAA1B;AACA;AACD,WAtBD,MAwBA;AACChC,YAAAA,SAAS,GAAG,KAAZ;AACAyB,YAAAA,cAAc,CAACpB,IAAf,CAAoB+B,SAAS,CAACnC,OAA9B;AACAyB,YAAAA,aAAa,CAACrB,IAAd,CAAmBuB,KAAnB;AACAtB,YAAAA,cAAc,CAACiB,OAAO,CAACW,yBAAT,EAAoCE,SAAS,CAACnC,OAA9C,CAAd;;AACA,gBAAGsB,OAAO,CAACY,mBAAX,EAA+B;AAC9B;AACA;AACD;AAED;AAGD;AAED;AAED;;AAED7B,EAAAA,cAAc,CAACiB,OAAO,CAACgB,WAAT,EAAsBd,cAAc,CAAClB,IAAf,CAAoB,KAApB,CAAtB,CAAd;AACA,SAAO;AACNP,IAAAA,SAAS,EAACA,SADJ;AAENwC,IAAAA,MAAM,EAAChB,gBAFD;AAGNE,IAAAA,aAAa,EAACA,aAHR;AAINe,IAAAA,eAAe,EAACd,gBAJV;AAKNF,IAAAA,cAAc,EAACA,cAAc,CAAClB,IAAf,CAAoB,KAApB;AALT,GAAP;AAQA,CAzFD;;AA2FAmC,MAAM,CAACC,OAAP,GAAiB/C,kBAAjB","sourcesContent":["var validator = require('validator');\n\nvalidator.toUpper = function (str) {\n\treturn str.toUpperCase();\n}\n\nvalidator.toLower = function (str) {\n\treturn str.toLowerCase();\n}\nvar morxParamExtractor = {};\n\nfunction validateParamValue(value, validators) {\n\n\tvar no_errors = true;\n\tvar message   = [];\n\tvalidators.forEach( function (v) {\n\t\tvFunc = validator[v];\n\n\t\tif(vFunc){\n\t\t\t\n\t\t\tif(!vFunc(value + '')){\n\t\t\t\tmessage.push(value + \" failed \" + v + \" validation\");\n\t\t\t\tno_errors = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrowErrorWhen(true, 'Validator ' + v + ' not found');\n\t\t}\n\n\t});\n\n\treturn {\n\t\t\tno_errors: no_errors,\n\t\t\tmessage: message.join(', ')\n\t\t}\n}\n\nfunction transformParamValue(value, filters) {\n\n\tfilters.forEach( function (f) {\n\n\t\tfilter = validator[f];\n\t\tif (filter)\n\t\t{\n\t\t\tvalue = filter(value + '');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrowErrorWhen(true, 'Filter ' + f + ' not found');\n\t\t}\n\t});\n\n\treturn value;\n}\n\nfunction throwErrorWhen(error_flag, message) {\n\tif(!message) return;\n\tif(error_flag){\n\t\tthrow new Error(message);\n\t}\n}\n\nmorxParamExtractor.registerValidator = function (validator_name, validator_func) {\n\t//todo v2\n}\n\n\nmorxParamExtractor.registerFilter = function (filter_name, filter_func) {\n\t//todo v2\n}\n\n//Todo v2 .. add multiple support for multiple param sources\nmorxParamExtractor.paramExtract = function (param_source, param_spec, options){\n\tparam_source = param_source || {};\n\tparam_spec   = param_spec   || {};\n\toptions      = options      || {};\n\n\tvar extracted_params = {};\n\tvar error_messages   = [];\n\tvar failed_params    = [];\n\tvar not_param_values = {};\n\n\tvar no_errors = true;\n\n\tfor(var param in param_spec){\n\n\t\tif (param_spec.hasOwnProperty(param)) {\n\n\t\t\tvar spec = param_spec[param];\n\n\t\t\tvar filters    = spec.filters    ? spec.filters.split('.')    : [];\n\t\t\tvar validators = spec.validators ? spec.validators.split('.') : []; \n\n\t\t\tvar param_value = param_source[param];\n\n\t\t\tif(spec.required == 'true' && (typeof param_value == 'undefined' || param_value === \"\")){\n\t\t\t\tno_errors = false;\n\t\t\t\terror_messages.push( param + ' is required' );\n\t\t\t\tfailed_params.push(param);\n\t\t\t\tthrowErrorWhen(options.throw_error_on_first_fail, error_messages.join(','));\n\t\t\t\tif(options.fail_on_first_error){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} \n\t\t\telse\n\t\t\t{\n\t\t\t\tif(typeof param_value != 'undefined'){\n\t\t\t\t\t\n\t\t\t\t\tvar validated = validateParamValue(param_value, validators);\n\t\t\t\t\tif(validated.no_errors)\n\t\t\t\t\t{\n\n\t\t\t\t\t\tparam_value = transformParamValue(param_value, filters);\n\t\t\t\t\t\t//If value is not needed as an extracted param ignore it.\n\t\t\t\t\t\tif(!spec.not_param){\n\t\t\t\t\t\t\tif(!spec.map)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(param_value)\n\t\t\t\t\t\t\t\textracted_params[param] = param_value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(param_value)\n\t\t\t\t\t\t\t\textracted_params[spec.map] = param_value; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(param_value)\n\t\t\t\t\t\t\tnot_param_values[param] = param_value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tno_errors = false;\n\t\t\t\t\t\terror_messages.push(validated.message);\n\t\t\t\t\t\tfailed_params.push(param);\n\t\t\t\t\t\tthrowErrorWhen(options.throw_error_on_first_fail, validated.message);\n\t\t\t\t\t\tif(options.fail_on_first_error){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthrowErrorWhen(options.throw_error, error_messages.join(' , '));\n\treturn {\n\t\tno_errors:no_errors,\n\t\tparams:extracted_params,\n\t\tfailed_params:failed_params,\n\t\texcluded_params:not_param_values,\n\t\terror_messages:error_messages.join(' , ')\n\t}\n\n}\n\nmodule.exports = morxParamExtractor;"]},"metadata":{},"sourceType":"script"}